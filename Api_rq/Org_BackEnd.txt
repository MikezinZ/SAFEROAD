SAFEROAD
 ‚îÇ backend/
 ‚îÇ ‚îú‚îÄ‚îÄ node_modules/ [‚úì]
 ‚îÇ ‚îú‚îÄ‚îÄ src/ [‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ config/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ databases.js [‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ controllers/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userController/ [‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ middleware/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.js [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authorize.js[‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ models/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.js [‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ routes/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authRouter.js [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userRouter.js [‚úì]
 ‚îÇ ‚îÇ   ‚îú‚îÄ‚îÄ tests/ [‚úì]
 ‚îÇ ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.tests.js [‚úì]
 ‚îÇ ‚îÇ   ‚îî‚îÄ‚îÄ index.js [‚úì]
 ‚îÇ ‚îú‚îÄ‚îÄ .env [‚úì]
 ‚îÇ ‚îú‚îÄ‚îÄ README.md [‚úì]
 ‚îÇ ‚îú‚îÄ‚îÄ package-lock.json [‚úì]
 ‚îÇ ‚îî‚îÄ‚îÄ package.json [‚úì]
 ‚îú‚îÄ‚îÄ frontend/[‚úì]
 ‚îú‚îÄ‚îÄ .gitattributes [‚úì]
 ‚îú‚îÄ‚îÄ project.txt [‚úì]
 ‚îî‚îÄ‚îÄ README.md [‚úì]

ESTRUTURA DE C√ìDIGO COMPLETA DE TODO BACKEND;

-------------------

backend/src/index.js:

require('dotenv').config();

// importa√ß√£oa de m√≥dulos
const express = require('express');
const cors = require('cors');
const serverless = require('serverless-http');
const swaggerUi = require('swagger-ui-express');
const swaggerJsDoc = require('swagger-jsdoc');
const userRoutes = require('./routes/userRoutes');
const authRoutes = require('./routes/authRoutes');
const { sequelize } = require('./models');

// Inicializa√ß√£o do express e configura√ß√£o do servidor
const app = express();
const PORT = process.env.PORT || 3000;

// Middleware para permitir requisi√ß√µes de diferentes origens
// const frontendURL = "https://saferoad-lime.vercel.app"
// app.use(cors({ origin: frontendURL }));
app.use(cors());
app.use(express.json());

// configura√ß√£o do swagger
const swaggerOptions = {
    definition: {
        openapi: '3.0.0',
        info: {
            title: 'User Management API',
            version: '1.0.0',
            description: 'API for user management and authentication',
        },
        servers: [
            {
                url: `http://localhost:${PORT}`,
            },
        ],
        components: {
            securitySchemes: {
                bearerAuth: {
                    type: 'http',
                    scheme: 'bearer',
                    bearerFormat: 'JWT'
                }
            }
        }
    },
    apis: ['./src/routes/*.js'], // Caminho para os arquivos com as anota√ß√µes Swagger
};

// Middleware para tratar erros do Swagger
app.use((err, req, res, next) => {
    if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        return res.status(400).json({ error: "Bad request - invalid JSON" });
    }
    next();
});

const swaggerDocs = swaggerJsDoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocs));

// Rotas 
app.use('/api/users', userRoutes);
app.use('/api/auth', authRoutes);

// tratamento de erro global
app.use((err, req, res, next) => {
    console.error("ERRO GLOBAL", err.stack);
    res.status(500).json({ message: 'Algo deu errado no servidor.', error: err.message });
});

// enedpoint de sa√∫de
app.get('/health', (req, res) => {
    res.status(200).json({ status: 'OK', message: 'Backend SAFEROAD est√° saud√°vel!' });
});

// sincroniza√ß√£o do banco de dados e inicializa√ß√£o do servidor
sequelize.sync()
    .then(() => {
        console.log('Sincroniza√ß√£o com o banco de dados (RDS) bem-sucedida.');
        if (process.env.NODE_ENV !== 'production_lambda') {
            app.listen(PORT, () => {
                console.log(`üî• Servidor LOCAL rodando na porta ${PORT}`);
                console.log(`üìÑ Documenta√ß√£o LOCAL: http://localhost:${PORT}/api-docs`);
            });
        }
    })
    .catch(err => {
        console.error('Falha ao sincronizar com o banco de dados:', err);

        if (process.env.NODE_ENV === 'production_lambda') {
            throw err;
        }
    });

module.exports.handler = serverless(app); 

--------------------------------

backend/src/controllers/authController.js: 

const jwt = require("jsonwebtoken");
const { User } = require('../models');

const JWT_SECRET = process.env.JWT_SECRET || "sua-chave-secreta";


// Controller de autentica√ß√£o
// Este controller gerencia o login e o registro de usu√°rios
class AuthController {
    async login(req, res) {
        // M√©todo para autenticar um usu√°rio    
        try {
            const { email, senha } = req.body;
            const user = await User.findOne({ where: { email } });
            if (!user) {
                return res.status(401).json({ message: "Credenciais inv√°lidas" });
            }

            const isValidPassword = await user.validatePassword(senha);
            if (!isValidPassword) {
                return res.status(401).json({ message: "Credenciais inv√°lidas" });
            }
            const token = jwt.sign(
                { id: user.id, email: user.email, role: user.role },
                JWT_SECRET,
                { expiresIn: "24h" }
            );

            res.json({
                token,
                user: {
                    id: user.id,
                    nome: user.nome, // Note que o campo √© 'nome'
                    email: user.email
                }
            });
        } catch (error) {
            res.status(500).json({ error: error.message });
        }
    }

    // M√©todo para registrar um novo usu√°rio
    async register(req, res) {
        try {
            const user = await User.create(req.body);
            const token = jwt.sign(
                { id: user.id, email: user.email },
                JWT_SECRET,
                { expiresIn: "24h" }
            );

            res.status(201).json({
                token,
                user: {
                    id: user.id,
                    username: user.nome,
                    email: user.email
                }
            });
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }
}

module.exports = new AuthController();

-----------

backend/src/controller/userController.js:

const { User } = require('../models');

const { User } = require('../models');


// a classe cont√©m os m√©todos respons√°veis por manipular e responder √†s requisi√ß√µes HTTP relacionadas a usu√°rios.
class UserController {


    async getAllUsers(req, res) {
        try {

            const page = parseInt(req.query.page, 10) || 1;
            const limit = parseInt(req.query.limit, 10) || 10;


            const offset = (page - 1) * limit;


            const { count, rows } = await User.findAndCountAll({
                attributes: ['id', 'nome', 'email', 'role'],
                limit: limit,
                offset: offset,
                order: [
                    ['id', 'ASC']
                ]
            });

            res.json({
                totalItems: count,
                totalPages: Math.ceil(count / limit),
                currentPage: page,
                users: rows
            });

        } catch (error) {
            console.error("Erro ao buscar usu√°rios com pagina√ß√£o:", error);
            res.status(500).json({ error: error.message });
        }
    }



    //  Recupera um usu√°rio espec√≠fico pelo ID.
    async getUserById(req, res) {
        try {
            const user = await User.findByPk(req.params.id, {
                attributes: ['id', 'nome', 'email']
            });
            if (!user) {
                return res.status(404).json({ message: 'Usuario n√£o encontrado' });
            }
            res.json(user);
        } catch (error) {
            res.status(500).json({ error: error.message });
        }
    }

    // Cria um novo usu√°rio
    async createUser(req, res) {
        try {
            const user = await User.create(req.body);
            res.status(201).json({
                id: user.id,
                nome: user.nome,
                email: user.email
            });
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }


    // Atualiza os dados de um usu√°rio espec√≠fico.
    async updateUser(req, res) {
        try {
            const user = await User.findByPk(req.params.id);
            if (!user) {
                return res.status(404).json({ message: 'Usuario n√£o encontrado' });
            }
            await user.update(req.body);
            res.json({
                id: user.id,
                nome: user.nome,
                email: user.email
            });
        } catch (error) {
            res.status(400).json({ error: error.message });
        }
    }

    //Deleta um usu√°rio espec√≠fico.
    async deleteUser(req, res) {
        try {
            const user = await User.findByPk(req.params.id);
            if (!user) {
                return res.status(404).json({ message: 'Usuario n√£o encontrado' });
            }
            await user.destroy();
            res.status(204).send();
        } catch (error) {
            res.status(500).json({ error: error.message });
        }
    }
}

module.exports = new UserController();

--------------
backend/src/middleware/authorize.js:

const authorize = (allowedRoles) => {
    return (req, res, next) => {

        const userRole = req.user?.role;

        if (!userRole) {
            return res.status(403).json({ message: "Acesso negado. Nenhuma fun√ß√£o de usu√°rio encontrada no token." });
        }

        if (allowedRoles.includes(userRole)) {

            next();
        } else {

            return res.status(403).json({ message: "Acesso negado. Voc√™ n√£o tem permiss√£o para executar esta a√ß√£o." });
        }
    };
};

module.exports = authorize;

----------------

backend/src/middleware/auth.js:

const jwt = require('jsonwebtoken'); // Importa o m√≥dulo jsonwebtoken

const JWT_SECRET = process.env.JWT_SECRET || 'sua-chave-secreta'; // Define a chave secreta para assinar os tokens JWT. Em produ√ß√£o, use uma vari√°vel de ambiente.


// Middleware de autentica√ß√£o
// Verifica se o token JWT √© v√°lido e adiciona os dados do usu√°rio √† requisi√ß√£o
const authMiddleware = (req, res, next) => {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
        return res.status(401).json({ message: 'Autentica√ß√£o necess√°ria' });
    }

    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ message: 'Token inv√°lido' });
    }
};

module.exports = authMiddleware;

-------------
backend/src/models/index.js:

const sequelize = require('../config/database');
const User = require('./user');

module.exports = {
    sequelize,
    User
};

-------------

backend/src/models/user.js:

// importa√ß√£o do sequelize e bcryptjs
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');
const bcrypt = require('bcryptjs');

// Define um modelo de usu√°rio com os campos id, nome, email e senha
const User = sequelize.define('User', {
    id: {
        type: DataTypes.INTEGER,
        primaryKey: true,
        autoIncrement: true
    },
    nome: {
        type: DataTypes.STRING,
        allowNull: false
    },
    email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
            isEmail: true,
        },
    },
    senha: {
        type: DataTypes.STRING,
        allowNull: false
    },
    role: {
        type: DataTypes.STRING,
        allowNull: false,
        defaultValue: 'user'
    }

},
    // o bloco de baixo √© um hook do sequelize que executa antes de criar um usu√°rio
    {
        hooks: {
            beforeCreate: async (user) => {
                if (user.senha) {
                    const salt = await bcrypt.genSalt(10);
                    user.senha = await bcrypt.hash(user.senha, salt);
                }
            }
        }

    }
);

// Define um m√©todo para verificar se a senha fornecida corresponde √† senha armazenada no banco de dados
// O m√©todo usa bcrypt para comparar a senha fornecida com a senha armazenada
User.prototype.validatePassword = async function (senha) {
    return await bcrypt.compare(senha, this.senha);
}

module.exports = User;

-----------------

backend/src/routes/authRoutes.js:

const express = require('express');
const authController = require('../controllers/authController');
const { body } = require('express-validator');

const router = express.Router();


// Swagger sem funcionar (quebrando c√≥digo)

// Define as rotas da API de autentica√ß√£o
/**
 * 
 * tags:
 *   name: Auth
 *   description: Autentica√ß√£o de usu√°rios
 */

/**
 *
 * /api/auth/login:
 *   post:
 *     summary: Login do usu√°rio
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *               senha:
 *                 type: string
 *     responses:
 *       200:
 *         description: Login bem sucedido
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 token:
 *                   type: string
 */

router.post('/login',
    [
        body('email').isEmail(),
        body('senha').exists()
    ],
    authController.login
);


/**
 * 
 * /api/auth/register:
 *   post:
 *     summary: Registrar novo usu√°rio
 *     tags: [Auth]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               nome:
 *                 type: string
 *               email:
 *                 type: string
 *               senha:
 *                 type: string
 *             required:
 *               - nome
 *               - email
 *               - senha
 *     responses:
 *       201:
 *         description: Usu√°rio registrado com sucesso
 *       400:
 *         description: Dados inv√°lidos
 */

// Define a rota para registrar um novo usu√°rio
router.post('/register',
    [
        body('nome').notEmpty(),
        body('email').isEmail(),
        body('senha').isLength({ min: 6 })
    ],
    authController.register
);

module.exports = router;
---------------
backend/src/routes/userRoutes.js:

const express = require('express');
const userController = require('../controllers/userController');
const { body, validationResult } = require('express-validator');
const authMiddleware = require('../middleware/auth');
const authorize = require('../middleware/authorize');

const router = express.Router(); // Cria uma inst√¢ncia do roteador


// Define as rotas da API de usu√°rios
/**

 * /api/users:
 *   get:
 *     summary: Obter todos os usu√°rios
 *     tags: [Users]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Lista de usu√°rios
 */

router.get('/', authMiddleware, userController.getAllUsers);


/**

 * /api/users/{id}:
 *   get:
 *   summary: Obter usu√°rio por ID
 *   tags: [Users]
 *   security:
 *    - bearerAuth: []
 *  parameters:
 *    - in: path
 *     name: id
 *     required: true
 *     schema:
 *      type: integer
 *  responses:
 *     200:
 *      description: Detalhes do usu√°rio
 */
router.get('/:id', authMiddleware, userController.getUserById);

/**
 * /api/users:
 *  post:
 *    summary: Criar um novo usu√°rio
 *    tags: [Users]
 *    security:
 *     - bearerAuth: []
 *    requestBody:
 *      required: true
 *      content:
 *        application/json:
 *           schema:
 *             type: object
 *             properties:
 *                nome:
 *                  type: string
 *                email:
 *                  type: string
 *                senha:
 *                  type: string
 *     responses:
 *         201:
 *           description: Usu√°rio criado com sucesso
 */
// Define a rota para criar um novo usu√°rio
// O middleware de autentica√ß√£o √© aplicado a esta rota
router.post('/',
    authMiddleware,
    [
        body('nome').notEmpty().withMessage('O campo nome √© obrigat√≥rio.'),
        body('email').isEmail().withMessage('Forne√ßa um email v√°lido.'),
        body('senha').isLength({ min: 6 }).withMessage('A senha precisa ter no m√≠nimo 6 caracteres.')
    ],
    (req, res, next) => { // Adicione esta fun√ß√£o intermedi√°ria
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            return res.status(400).json({ errors: errors.array() });
        }
        next();
    },
    userController.createUser
);

/**

 * /api/users/{id}:
 *   put:
 *     summary: Atualizar usu√°rio por ID
 *     tags: [Users]
 *     security:
 *      - bearerAuth: []
 *    parameters:
 *      - in: path
 *        name: id
 *        required: true
 *        schema:
 *          type: integer
 *    requestBody:
 *     required: true
 *     content:
 *       application/json:
 *         schema:
 *          type: object
 *         properties:
 *          nome:
 *           type: string
 *          email:
 *           type: string
 *    responses:
 *      200:
 * *       description: Usu√°rio atualizado com sucesso
 */
router.put('/:id', authMiddleware, userController.updateUser);

/**

 * /api/users/{id}:
 *   delete:
 *     summary: Deletar usu√°rio por ID
 *     tags: [Users]
 *     security:
 *        - bearerAuth: []
 *    parameters:
 *     - in: path
 *       name: id
 *      required: true
 *      schema:
 *       type: integer
 *    responses:
 *     204:
 *     description: Usu√°rio deletado com sucesso
 */
router.delete('/:id', authMiddleware, authorize(['admin']), userController.deleteUser);

module.exports = router;

---------------

backend/src/tests/auth.test.js:

const request = require('supertest');
const app = require('../index');
const { User } = require('../models');

describe('Endpoints de Autenticacao', () => {
    beforeEach(async () => {
        await User.destroy({ where: {} });
    });

    describe('POST /api/auth/register', () => {
        it('deve criar um novo usu√°rio', async () => {
            const res = await request(app)
                .post('/api/auth/register')
                .send({
                    nome: 'testuser',
                    email: 'test@test.com',
                    senha: 'password123'
                });

            expect(res.statusCode).toEqual(201);
            expect(res.body).toHaveProperty('token');
            expect(res.body.user).toHaveProperty('id');
        });
    });

    describe('POST /api/auth/login', () => {
        beforeEach(async () => {
            await request(app)
                .post('/api/auth/register')
                .send({
                    nome: 'testuser',
                    email: 'test@test.com',
                    senha: 'password123'
                });
        });

        it('deve fazer login no usu√°rio existente', async () => {
            const res = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'test@test.com',
                    senha: 'password123'
                });

            expect(res.statusCode).toEqual(200);
            expect(res.body).toHaveProperty('token');
        });
    });
});


---------------

backend/src/config/database.js:

require('dotenv').config();
const { Sequelize } = require('sequelize');

const dbUrl = process.env.DATABASE_URL;

if (!dbUrl) {
    const errorMessage = "ERRO CR√çTICO: DATABASE_URL n√£o est√° definida nas vari√°veis de ambiente! O servidor n√£o pode iniciar sem ela.";
    console.error(errorMessage);
    throw new Error(errorMessage);
}

const sequelize = new Sequelize(process.env.DATABASE_URL, {
    dialect: 'postgres',
    dialectOptions: {
        ssl: {
            require: true,
            rejectUnauthorized: false
        }
    },
    logging: false
});

module.exports = sequelize;

--------------

backend/.env:

JWT_SECRET=SafeCode_Code
PORT=3000
DATABASE_URL="postgresql://saferoadadmin:MigPigrds10!@saferoad-db-instance.ctgq6awc2dce.us-east-2.rds.amazonaws.com:5432/saferoad_database"
-------------------

backend/package.json:
{
  "name": "backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "nodemon src/index.js",
    "start": "node src/index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@fastify/swagger": "^9.4.2",
    "bcryptjs": "^3.0.2",
    "body-parser": "^2.2.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-validator": "^7.2.1",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.16.0",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.37.6",
    "serverless-http": "^3.2.0",
    "swagger-jsdoc": "^6.0.0",
    "swagger-ui-express": "^5.0.1"
  },
  "devDependencies": {
    "jest": "^29.7.0",
    "nodemon": "^3.1.9",
    "swagger-autogen": "^2.23.7"
  }
}

---------------------------